<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Yurii Zinets</title><link>https://yuriizinets.github.io/</link><description>Yurii Zinets</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 07 Jan 2022 09:41:32 +0100</lastBuildDate><atom:link href="https://yuriizinets.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>[RU] Почему SPA это не всегда хорошая идея</title><link>https://yuriizinets.github.io/posts/why-spa-is-not-always-a-good-idea-ru/</link><pubDate>Fri, 07 Jan 2022 09:41:32 +0100</pubDate><guid>https://yuriizinets.github.io/posts/why-spa-is-not-always-a-good-idea-ru/</guid><description>&lt;p>Давайте представим что у вас есть:&lt;/p>
&lt;ul>
&lt;li>Задача по разработке платформы для продажи недвижимости&lt;/li>
&lt;li>Небольшая команда из 3 человек&lt;/li>
&lt;li>Полная свобода выбора стека технологий&lt;/li>
&lt;/ul>
&lt;p>Несмотря на хорошие предпосылки (как нам казалось), мы умудрились полностью &amp;ldquo;убить&amp;rdquo; производительность фронтенда первой прототипной версии.
С этого момента я бы хотел рассмотреть основные причины нашего провала и как мы смогли из этого выбраться.&lt;/p>
&lt;h2 id="выбор-технологий-для-фронтенда">Выбор технологий для фронтенда
&lt;span>&lt;a href="#%d0%b2%d1%8b%d0%b1%d0%be%d1%80-%d1%82%d0%b5%d1%85%d0%bd%d0%be%d0%bb%d0%be%d0%b3%d0%b8%d0%b9-%d0%b4%d0%bb%d1%8f-%d1%84%d1%80%d0%be%d0%bd%d1%82%d0%b5%d0%bd%d0%b4%d0%b0">#&lt;/a>&lt;/span>
&lt;/h2>&lt;p>Мы недолго думали над выбором стека с которыми будем работать. Так же мы не думали о том как это поддерживать в будущем, ведь мы же прототип делаем. Нас интересовала гибкость и скорость разработки. В условиях неопределённости это ключевые факторы. Наш выбор остановился на FastAPI для бэкенда и Vue+Quasar для фронтенда.&lt;/p>
&lt;h2 id="обманчивая-простота">Обманчивая простота
&lt;span>&lt;a href="#%d0%be%d0%b1%d0%bc%d0%b0%d0%bd%d1%87%d0%b8%d0%b2%d0%b0%d1%8f-%d0%bf%d1%80%d0%be%d1%81%d1%82%d0%be%d1%82%d0%b0">#&lt;/a>&lt;/span>
&lt;/h2>&lt;p>Богатая библиотека material компонентов и гибкость Vue позволили нам быстро опробовать разные идеи. От простых UI/UX экспериментов до кардинальных изменений в концепции. Компонентный подход помог нам сконцентрироваться на конкретных вещах и проблемах, связанных с бизнесом вместо погружения в технологические детали. Без особых усилий мы создавали целые наборы конфигурируемых компонентов для наших страниц.&lt;/p>
&lt;h2 id="скрытая-цена">Скрытая цена
&lt;span>&lt;a href="#%d1%81%d0%ba%d1%80%d1%8b%d1%82%d0%b0%d1%8f-%d1%86%d0%b5%d0%bd%d0%b0">#&lt;/a>&lt;/span>
&lt;/h2>&lt;p>&lt;img src="https://yuriizinets.github.io/why-spa-is-not-always-a-good-idea-1.jpg" alt="meme">&lt;/p>
&lt;p>Во время разработки прототипа мы упускаем из виду много вещей. Это нормально, естественно и не является проблемой само по себе. Проблема возникает только тогда, когда мы не закладываем это в планы. Давайте немного подробнее рассмотрим скрытый &amp;ldquo;прайс-лист&amp;rdquo; в конкретно нашей ситуации:&lt;/p>
&lt;ol>
&lt;li>Каждое глубокое изменение концепции оставляет свой legacy &amp;ldquo;шрам&amp;rdquo; на проекте. Когда мы двигаемся быстро, меняем подход или в корне пересматриваем идею проекта, то редко задумываемся о глубокой чистке проекта от неактуального функционала.&lt;/li>
&lt;li>&amp;ldquo;Сейчас UI, технические потребности потом&amp;rdquo;. Рассмотрим это подробнее немного позже.&lt;/li>
&lt;li>&amp;ldquo;Зачем выкидывать то что есть? У нас же почти готовый проект!&amp;rdquo;. Знакомый всем камень преткновения, когда основная концепция проекта обретает чёткие очертания и пора задумываться о более глубоких технических вещах.&lt;/li>
&lt;/ol>
&lt;h2 id="первые-звоночки">Первые &amp;ldquo;звоночки&amp;rdquo;
&lt;span>&lt;a href="#%d0%bf%d0%b5%d1%80%d0%b2%d1%8b%d0%b5-%d0%b7%d0%b2%d0%be%d0%bd%d0%be%d1%87%d0%ba%d0%b8">#&lt;/a>&lt;/span>
&lt;/h2>&lt;p>Достаточно было зайти в lighthouse, чтобы осознать назревающую проблему, которую всё ещё замалчивали. Результирующий репорт просто вопил о проблемах с производительностью и SEO. Зелёная плашка &amp;ldquo;PWA&amp;rdquo; не сильно успокаивала. Тем временем в списке начали появляться задачи напрямую с этим связанные. И я вас уверяю, выяснение причин низкой производительности - весьма непростая задача для человека, слабо связанного с фронтендом. Сказывается та самая мнимая простота, о которой говорят и пишут все кому не лень. Но самые интересные последствия мы словили, когда попытались включить и разобраться в SSR режиме. В этот момент мы поняли, что следовало сразу вести разработку с учётом этой специфики. Делать это спустя месяцы разработки очень сложно. Интересный момент в том, что каждый фреймворк на основе Vue имеет свой подход к SSR, включая Quasar. В этот момент наша идеология самодостаточных компонентов рухнула, так как этот режим требовал работы через Vuex. Весь SSR выглядит как попытка решить ситуацию, которой не должно было случиться.&lt;/p>
&lt;h2 id="критическая-точка">Критическая точка
&lt;span>&lt;a href="#%d0%ba%d1%80%d0%b8%d1%82%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%b0%d1%8f-%d1%82%d0%be%d1%87%d0%ba%d0%b0">#&lt;/a>&lt;/span>
&lt;/h2>&lt;p>Перечисленные выше проблемы имеют накопительный эффект. Требуемое время на внедрение новых изменений увеличивается с каждой из них. Довольно сложным этапом для нас стала утечка памяти на стороне сервера. Буду краток, побороть утечку так и не удалось. Эту проблему мы &amp;ldquo;решили&amp;rdquo; балансировкой нагрузки с повторными попытками и перезагрузкой контейнеров при вылете. В момент когда цена внедрения и поддержки превысила все мыслимые ожидания, всё внимание перешло к технической составляющей и было решено пересмотреть изначальный подход.&lt;/p>
&lt;h2 id="пересмотр-идеологии">Пересмотр идеологии
&lt;span>&lt;a href="#%d0%bf%d0%b5%d1%80%d0%b5%d1%81%d0%bc%d0%be%d1%82%d1%80-%d0%b8%d0%b4%d0%b5%d0%be%d0%bb%d0%be%d0%b3%d0%b8%d0%b8">#&lt;/a>&lt;/span>
&lt;/h2>&lt;p>Этот этап должен был наступить ещё давно.&lt;/p>
&lt;p>Первый вывод, который мы сделали - SPA это немного не то, что нам нужно. Следует разделять понятие вебсайта и веб приложения. Тянуть тяжёлый runtime, Virtual DOM и всё приложение для того чтобы просто показать статью или общую информацию о недвижимости. Масла в огонь подливает lazy loading, который не работает так, как хотелось бы. Основной объём в приложении составляют внешние библиотеки (например карты) которые загружаются одним файлом вместе с загрузкой основного приложения, вне зависимости от того требуются ли они на текущей странице.&lt;/p>
&lt;p>Второй вывод - контроль над проектом. Не многие люди действительно понимают как их проект работает под капотом и через что проходит их код (и не только их) перед тем как попасть в браузер. Под лёгким стартом проекта скрыто немало сложных вещей, взять тот же webpack с тонной конфигураций.&lt;/p>
&lt;h2 id="альтернатива">Альтернатива?
&lt;span>&lt;a href="#%d0%b0%d0%bb%d1%8c%d1%82%d0%b5%d1%80%d0%bd%d0%b0%d1%82%d0%b8%d0%b2%d0%b0">#&lt;/a>&lt;/span>
&lt;/h2>&lt;p>Мы решили пойти более простым и традиционным путём. Серверные шаблоны хорошо подошли под наши требования, учитывая что у нас не так уж много динамики. Одним решением мы берём под контроль то, что идёт на сторону браузера, избавились от проблем с SSR и значительно упростили принципы по которым работает наш сайт.&lt;/p>
&lt;p>Ударившись в крайности, мы выбрали Go и &lt;code>html/template&lt;/code> из стандартной библиотеки, так как некоторые модули нашей платформы уже были написаны на Go и мы имели представление о нём. О выборе мы не пожалели и всё работает замечательно.&lt;/p>
&lt;h2 id="процесс-миграции">Процесс миграции
&lt;span>&lt;a href="#%d0%bf%d1%80%d0%be%d1%86%d0%b5%d1%81%d1%81-%d0%bc%d0%b8%d0%b3%d1%80%d0%b0%d1%86%d0%b8%d0%b8">#&lt;/a>&lt;/span>
&lt;/h2>&lt;p>Миграция не происходила сразу. Велось 2 параллельных проекта, при этом вкладывая больше ресурсов в новый. После первой демонстрационной беты мы не стали ждать переноса всего функционала и запустили новую версию. Несмотря на это, опыт пользования сайтом улучшился в разы.&lt;/p>
&lt;h2 id="компромиссы">Компромиссы
&lt;span>&lt;a href="#%d0%ba%d0%be%d0%bc%d0%bf%d1%80%d0%be%d0%bc%d0%b8%d1%81%d1%81%d1%8b">#&lt;/a>&lt;/span>
&lt;/h2>&lt;p>Конечно, вместе с этим мы добавили и сложности. Помните? У всего есть своя цена. Благо, эти сложности связаны именно с самим кодом и слабо влияют на итоговый результат в браузере.&lt;/p>
&lt;p>Несмотря на разделение кода, наши контроллеры превратились в сплошное спагетти. Основной причиной послужило отсутствие async/await синтаксиса в Go. На самом деле система корутин в Go вызывает восхищение, но в некоторых местах весьма многословна. Со временем мы начали всё чаще замечать copy-paste подход. Система шаблонов не на столько гибкая, чтобы дробить всё на небольшие компоненты. И нужно признаться, Vanilla JS бывает многословным даже для простых вещей.&lt;/p>
&lt;p>Это всё не критичные моменты, тем не менее, хотелось бы иметь решение для них. Таким образом родилась библиотека &lt;a href="https://github.com/kyoto-framework/kyoto">&lt;code>kyoto&lt;/code>&lt;/a> и тема для отдельной статьи.&lt;/p>
&lt;h2 id="итог">Итог
&lt;span>&lt;a href="#%d0%b8%d1%82%d0%be%d0%b3">#&lt;/a>&lt;/span>
&lt;/h2>&lt;p>Не сомневаюсь что кто-то упомянет нашу некомпетентность в сфере фронтенда или неправильный выбор фреймворка. Это справедливо, и всё же я хотел бы упомянуть несколько вещей:&lt;/p>
&lt;ul>
&lt;li>Современные JS фреймворки зачастую преподносят как нечто простое, с чем легко стартовать проект. Но никто не упоминает как сложно этот проект развивать, сопровождать и отлаживать.&lt;/li>
&lt;li>Основополагающие принципы работы фреймворков по большей части совпадают, справедливо предположить что и проблемы схожи.&lt;/li>
&lt;li>Многие (включая нас) забывают о последнем слове в аббревиатуре SPA. Использование технологий не по назначению имеет свои последствия.&lt;/li>
&lt;/ul>
&lt;p>Желаю тем, кто дочитал это до конца сделать свои выводы из нашего провала и избежать своего!&lt;/p></description></item></channel></rss>