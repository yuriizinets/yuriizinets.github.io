---
title: "[RU] Почему SPA это не всегда хорошая идея"
date: 2022-01-07T09:41:32+01:00
draft: false
---

Давайте представим что у вас есть:

- Задача по разработке платформы для продажи недвижимости
- Небольшая команда из 3 человек
- Полная свобода выбора стека технологий

Несмотря на хорошие предпосылки (как нам казалось), мы умудрились полностью "убить" производительность фронтенда первой прототипной версии.
С этого момента я бы хотел рассмотреть основные причины нашего провала и как мы смогли из этого выбраться.

<!--more-->

## Выбор технологий для фронтенда

Мы недолго думали над выбором стека с которыми будем работать. Так же мы не думали о том как это поддерживать в будущем, ведь мы же прототип делаем. Нас интересовала гибкость и скорость разработки. В условиях неопределённости это ключевые факторы. Наш выбор остановился на FastAPI для бэкенда и Vue+Quasar для фронтенда.

## Обманчивая простота

Богатая библиотека material компонентов и гибкость Vue позволили нам быстро опробовать разные идеи. От простых UI/UX экспериментов до кардинальных изменений в концепции. Компонентный подход помог нам сконцентрироваться на конкретных вещах и проблемах, связанных с бизнесом вместо погружения в технологические детали. Без особых усилий мы создавали целые наборы конфигурируемых компонентов для наших страниц.

## Скрытая цена

![meme](/why-spa-is-not-always-a-good-idea-1.jpg)

Во время разработки прототипа мы упускаем из виду много вещей. Это нормально, естественно и не является проблемой само по себе. Проблема возникает только тогда, когда мы не закладываем это в планы. Давайте немного подробнее рассмотрим скрытый "прайс-лист" в конкретно нашей ситуации:

1. Каждое глубокое изменение концепции оставляет свой legacy "шрам" на проекте. Когда мы двигаемся быстро, меняем подход или в корне пересматриваем идею проекта, то редко задумываемся о глубокой чистке проекта от неактуального функционала.
2. "Сейчас UI, технические потребности потом". Рассмотрим это подробнее немного позже.
3. "Зачем выкидывать то что есть? У нас же почти готовый проект!". Знакомый всем камень преткновения, когда основная концепция проекта обретает чёткие очертания и пора задумываться о более глубоких технических вещах.

## Первые "звоночки"

Достаточно было зайти в lighthouse, чтобы осознать назревающую проблему, которую всё ещё замалчивали. Результирующий репорт просто вопил о проблемах с производительностью и SEO. Зелёная плашка "PWA" не сильно успокаивала. Тем временем в списке начали появляться задачи напрямую с этим связанные. И я вас уверяю, выяснение причин низкой производительности - весьма непростая задача для человека, слабо связанного с фронтендом. Сказывается та самая мнимая простота, о которой говорят и пишут все кому не лень. Но самые интересные последствия мы словили, когда попытались включить и разобраться в SSR режиме. В этот момент мы поняли, что следовало сразу вести разработку с учётом этой специфики. Делать это спустя месяцы разработки очень сложно. Интересный момент в том, что каждый фреймворк на основе Vue имеет свой подход к SSR, включая Quasar. В этот момент наша идеология самодостаточных компонентов рухнула, так как этот режим требовал работы через Vuex. Весь SSR выглядит как попытка решить ситуацию, которой не должно было случиться.

## Критическая точка

Перечисленные выше проблемы имеют накопительный эффект. Требуемое время на внедрение новых изменений увеличивается с каждой из них. Довольно сложным этапом для нас стала утечка памяти на стороне сервера. Буду краток, побороть утечку так и не удалось. Эту проблему мы "решили" балансировкой нагрузки с повторными попытками и перезагрузкой контейнеров при вылете. В момент когда цена внедрения и поддержки превысила все мыслимые ожидания, всё внимание перешло к технической составляющей и было решено пересмотреть изначальный подход.

## Пересмотр идеологии

Этот этап должен был наступить ещё давно.

Первый вывод, который мы сделали - SPA это немного не то, что нам нужно. Следует разделять понятие вебсайта и веб приложения. Тянуть тяжёлый runtime, Virtual DOM и всё приложение для того чтобы просто показать статью или общую информацию о недвижимости. Масла в огонь подливает lazy loading, который не работает так, как хотелось бы. Основной объём в приложении составляют внешние библиотеки (например карты) которые загружаются одним файлом вместе с загрузкой основного приложения, вне зависимости от того требуются ли они на текущей странице.

Второй вывод - контроль над проектом. Не многие люди действительно понимают как их проект работает под капотом и через что проходит их код (и не только их) перед тем как попасть в браузер. Под лёгким стартом проекта скрыто немало сложных вещей, взять тот же webpack с тонной конфигураций.

## Альтернатива?

Мы решили пойти более простым и традиционным путём. Серверные шаблоны хорошо подошли под наши требования, учитывая что у нас не так уж много динамики. Одним решением мы берём под контроль то, что идёт на сторону браузера, избавились от проблем с SSR и значительно упростили принципы по которым работает наш сайт.  

Ударившись в крайности, мы выбрали Go и `html/template` из стандартной библиотеки, так как некоторые модули нашей платформы уже были написаны на Go и мы имели представление о нём. О выборе мы не пожалели и всё работает замечательно.

## Процесс миграции

Миграция не происходила сразу. Велось 2 параллельных проекта, при этом вкладывая больше ресурсов в новый. После первой демонстрационной беты мы не стали ждать переноса всего функционала и запустили новую версию. Несмотря на это, опыт пользования сайтом улучшился в разы.

## Компромиссы

Конечно, вместе с этим мы добавили и сложности. Помните? У всего есть своя цена. Благо, эти сложности связаны именно с самим кодом и слабо влияют на итоговый результат в браузере.

Несмотря на разделение кода, наши контроллеры превратились в сплошное спагетти. Основной причиной послужило отсутствие async/await синтаксиса в Go. На самом деле система корутин в Go вызывает восхищение, но в некоторых местах весьма многословна. Со временем мы начали всё чаще замечать copy-paste подход. Система шаблонов не на столько гибкая, чтобы дробить всё на небольшие компоненты. И нужно признаться, Vanilla JS бывает многословным даже для простых вещей.

Это всё не критичные моменты, тем не менее, хотелось бы иметь решение для них. Таким образом родилась библиотека [`kyoto`](https://github.com/kyoto-framework/kyoto) и тема для отдельной статьи.

## Итог

Не сомневаюсь что кто-то упомянет нашу некомпетентность в сфере фронтенда или неправильный выбор фреймворка. Это справедливо, и всё же я хотел бы упомянуть несколько вещей:

- Современные JS фреймворки зачастую преподносят как нечто простое, с чем легко стартовать проект. Но никто не упоминает как сложно этот проект развивать, сопровождать и отлаживать.
- Основополагающие принципы работы фреймворков по большей части совпадают, справедливо предположить что и проблемы схожи.
- Многие (включая нас) забывают о последнем слове в аббревиатуре SPA. Использование технологий не по назначению имеет свои последствия.

Желаю тем, кто дочитал это до конца сделать свои выводы из нашего провала и избежать своего!
